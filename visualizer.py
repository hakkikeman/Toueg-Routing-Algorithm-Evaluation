import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
import math
import numpy as np
import random
import json
import os

# --- CONFIGURATION ---
ROUTES_FILE = 'routes.csv'
AIRPORTS_FILE = 'airports.csv'
DEFAULT_RESULTS_FILE = 'simulation_results.json'

# --- DATA LOADING ---

def load_simulation_results(filename):
    """
    Loads simulation metrics from the JSON file generated by main_runner.py.
    If file is not found, returns None.
    """
    if not os.path.exists(filename):
        print(f"[WARNING] Results file '{filename}' not found. Visuals might be empty.")
        return None
    
    with open(filename, 'r') as f:
        data = json.load(f)
    return data

# --- HELPER FUNCTIONS ---
def haversine_distance(lat1, lon1, lat2, lon2):
    """Calculates Haversine distance for edge weighting."""
    R = 6371
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlambda = math.radians(lon2 - lon1)
    a = math.sin(dphi / 2)**2 + math.cos(phi1) * math.cos(phi2) * math.sin(dlambda / 2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return int(R * c)

def load_graph_for_viz(num_nodes):
    """Loads graph data for visualization purposes."""
    print(f"--- Loading Data for Visualization ({num_nodes} Nodes) ---")
    
    # Load Airports
    try:
        df_airports = pd.read_csv(AIRPORTS_FILE, low_memory=False)
    except FileNotFoundError:
        print(f"[ERROR] {AIRPORTS_FILE} not found.")
        return nx.DiGraph(), {}, {}

    df_airports.columns = df_airports.columns.str.strip()
    
    airport_locs = {}
    airport_labels = {}
    
    for _, row in df_airports.iterrows():
        try:
            aid = int(row['Airport ID'])
            lat = float(row['Latitude'])
            lon = float(row['Longitude'])
            iata = str(row['IATA'])
            airport_locs[aid] = (lon, lat) 
            airport_labels[aid] = iata
        except: continue
            
    # Load Routes
    try:
        df_routes = pd.read_csv(ROUTES_FILE, low_memory=False)
    except FileNotFoundError:
        print(f"[ERROR] {ROUTES_FILE} not found.")
        return nx.DiGraph(), {}, {}

    df_routes.columns = df_routes.columns.str.strip()
    df_routes = df_routes[pd.to_numeric(df_routes['Source airport ID'], errors='coerce').notnull()]
    
    top_airports = df_routes['Source airport ID'].astype(int).value_counts().head(num_nodes).index.tolist()
    
    G = nx.DiGraph()
    pos = {}
    labels = {}
    
    for aid in top_airports:
        if aid in airport_locs:
            G.add_node(aid)
            pos[aid] = airport_locs[aid]
            labels[aid] = airport_labels.get(aid, str(aid))

    for _, row in df_routes.iterrows():
        try:
            src = int(row['Source airport ID'])
            dst = int(row['Destination airport ID'])
            if src in top_airports and dst in top_airports and src in pos and dst in pos:
                lon1, lat1 = pos[src]
                lon2, lat2 = pos[dst]
                dist = haversine_distance(lat1, lon1, lat2, lon2)
                if not G.has_edge(src, dst):
                    G.add_edge(src, dst, weight=dist)
        except: continue
            
    final_pos = {n: pos[n] for n in G.nodes()}
    final_labels = {n: labels[n] for n in G.nodes()}
    
    return G, final_pos, final_labels

def make_graph_sparse_viz(G, keep_prob=0.2):
    """Sparsifies the graph for visualization purposes."""
    G_sparse = G.copy()
    edges = list(G_sparse.edges())
    random.seed(42) 
    for u, v in edges:
        if random.random() > keep_prob:
            try: G_sparse.remove_edge(u, v)
            except: pass
    return G_sparse

# --- PLOTTING FUNCTIONS ---

def plot_connectivity_visuals(results):
    """
    Generates side-by-side comparison of Dense vs Sparse graphs (10 Nodes).
    Performance metrics are fetched dynamically from results.
    """
    if not results: return

    # Extract Data from Results
    data_dense = results.get('exp2_connectivity', {}).get('dense_10', {})
    data_sparse = results.get('exp2_connectivity', {}).get('sparse_10', {})
    
    # 1. Load Dense Graph
    G_dense, pos, labels = load_graph_for_viz(10)
    
    # 2. Create Sparse Version
    G_sparse = make_graph_sparse_viz(G_dense, keep_prob=0.3) 
    
    # Setup Plot
    fig, axes = plt.subplots(1, 2, figsize=(16, 9))
    fig.suptitle('Experiment 2: Connectivity Analysis (10 Nodes)', fontsize=20, fontweight='bold', y=0.98)
    
    # --- PLOT 1: DENSE ---
    avg_deg_dense = sum(dict(G_dense.degree()).values()) / len(G_dense) if len(G_dense) > 0 else 0
    nx.draw_networkx_nodes(G_dense, pos, ax=axes[0], node_size=800, node_color='#2E86C1', edgecolors='white')
    nx.draw_networkx_labels(G_dense, pos, labels, ax=axes[0], font_size=10, font_weight='bold', font_color='white')
    nx.draw_networkx_edges(G_dense, pos, ax=axes[0], edge_color='gray', alpha=0.5, arrows=True)
    
    axes[0].set_title(f"Scenario A: Dense Graph\n(Avg Degree: {avg_deg_dense:.1f})", fontsize=14, fontweight='bold')
    axes[0].axis('off')
    
    # Metrics Box Dense
    textstr_dense = '\n'.join((
        r'$\bf{PERFORMANCE\ METRICS}$',
        f"Execution Time: {data_dense.get('Time', 'N/A')}",
        f"Message Count: {data_dense.get('Messages', 'N/A')}",
        f"Validation Accuracy: {data_dense.get('Accuracy', 'N/A')}",
        r"$\it{Status: High\ Cost,\ High\ Accuracy}$"
    ))
    props = dict(boxstyle='round', facecolor='wheat', alpha=0.3)
    axes[0].text(0.5, -0.05, textstr_dense, transform=axes[0].transAxes, fontsize=11,
                horizontalalignment='center', verticalalignment='top', bbox=props)

    # --- PLOT 2: SPARSE ---
    avg_deg_sparse = sum(dict(G_sparse.degree()).values()) / len(G_sparse) if len(G_sparse) > 0 else 0
    nx.draw_networkx_nodes(G_sparse, pos, ax=axes[1], node_size=800, node_color='#E74C3C', edgecolors='white')
    nx.draw_networkx_labels(G_sparse, pos, labels, ax=axes[1], font_size=10, font_weight='bold', font_color='white')
    nx.draw_networkx_edges(G_sparse, pos, ax=axes[1], edge_color='black', alpha=0.6, arrows=True, style='dashed')
    
    axes[1].set_title(f"Scenario B: Sparse Graph\n(Avg Degree: {avg_deg_sparse:.1f})", fontsize=14, fontweight='bold')
    axes[1].axis('off')
    
    # Metrics Box Sparse
    textstr_sparse = '\n'.join((
        r'$\bf{PERFORMANCE\ METRICS}$',
        f"Execution Time: {data_sparse.get('Time', 'N/A')}",
        f"Message Count: {data_sparse.get('Messages', 'N/A')}",
        f"Validation Accuracy: {data_sparse.get('Accuracy', 'N/A')}",
        r"$\it{Status: Low\ Cost,\ Low\ Accuracy}$"
    ))
    axes[1].text(0.5, -0.05, textstr_sparse, transform=axes[1].transAxes, fontsize=11,
                horizontalalignment='center', verticalalignment='top', bbox=props)

    plt.subplots_adjust(bottom=0.2) 
    filename = "Connectivity_Analysis_Dense_vs_Sparse.png"
    plt.savefig(filename, dpi=300, bbox_inches='tight')
    print(f"Saved: {filename}")
    plt.close()

def plot_comparison_chart_exp3(results):
    """Generates the Algorithm Comparison Chart (Bar Plot) for Experiment 3."""
    if not results: return

    data_exp3 = results.get('exp3_complexity', {})
    toueg_vals = data_exp3.get('toueg', [0,0,0])
    floyd_vals = data_exp3.get('floyd', [0,0,0])
    
    fig, axes = plt.subplots(1, 3, figsize=(18, 6))
    fig.suptitle('Experiment 3: Complexity Comparison (Sparse Graph - 50 Nodes)', fontsize=20, fontweight='bold')
    colors = ['#2E86C1', '#E74C3C']
    labels = ['Toueg (Algo 7.5)', 'Dist. Floyd (Algo 7.4)']
    x = np.arange(1)
    width = 0.35

    # 1. Time
    axes[0].bar(x - width/2, toueg_vals[0], width, color=colors[0], label=labels[0])
    axes[0].bar(x + width/2, floyd_vals[0], width, color=colors[1], label=labels[1])
    axes[0].set_title('Execution Time (Lower is Better)', fontsize=14)
    axes[0].set_ylabel('Seconds')
    axes[0].set_xticks([])
    axes[0].text(x - width/2, toueg_vals[0], f"{toueg_vals[0]:.3f}s", ha='center', va='bottom', fontweight='bold')
    axes[0].text(x + width/2, floyd_vals[0], f"{floyd_vals[0]:.3f}s", ha='center', va='bottom', fontweight='bold')

    # 2. Messages
    axes[1].bar(x - width/2, toueg_vals[1], width, color=colors[0])
    axes[1].bar(x + width/2, floyd_vals[1], width, color=colors[1])
    axes[1].set_title('Message Complexity', fontsize=14)
    axes[1].set_ylabel('Count')
    axes[1].set_xticks([])
    axes[1].text(x - width/2, toueg_vals[1], f"{toueg_vals[1]}", ha='center', va='bottom', fontweight='bold')
    axes[1].text(x + width/2, floyd_vals[1], f"{floyd_vals[1]}", ha='center', va='bottom', fontweight='bold')

    # 3. Bits
    axes[2].bar(x - width/2, toueg_vals[2], width, color=colors[0])
    axes[2].bar(x + width/2, floyd_vals[2], width, color=colors[1])
    axes[2].set_title('Bit Complexity (Data Volume)', fontsize=14)
    axes[2].set_ylabel('Bits')
    axes[2].set_xticks([])
    
    t_mb = toueg_vals[2]/1e6
    f_mb = floyd_vals[2]/1e6
    axes[2].text(x - width/2, toueg_vals[2], f"{t_mb:.1f} Mb", ha='center', va='bottom', fontweight='bold')
    axes[2].text(x + width/2, floyd_vals[2], f"{f_mb:.1f} Mb", ha='center', va='bottom', fontweight='bold')

    fig.legend(labels, loc='upper right', bbox_to_anchor=(0.95, 0.95), fontsize=12)
    plt.tight_layout(rect=[0, 0.03, 1, 0.90])
    plt.savefig("Comparison_Toueg_vs_Floyd.png", dpi=300)
    plt.close()

def plot_scale_charts_exp1(results):
    """Generates Scalability BAR Charts for Experiment 1."""
    if not results:
        return

    data_scale = results.get('exp1_scale', {})
    nodes = data_scale.get('nodes', [])
    messages = data_scale.get('messages', [])
    times = data_scale.get('time', [])

    if not nodes:
        return

    colors = ['#2E86C1', '#27AE60', '#F39C12', '#8E44AD', '#E74C3C']
    x_pos = np.arange(len(nodes))

    # ===============================
    # BAR CHART 1: TOTAL MESSAGES
    # ===============================
    plt.figure(figsize=(10, 6))
    bars = plt.bar(x_pos, messages, color=colors)

    plt.xticks(x_pos, nodes)
    plt.xlabel("Node Count")
    plt.ylabel("Total Messages")
    plt.title("Experiment 1: Message Explosion (Scale Test)", fontweight='bold')
    plt.grid(axis='y', linestyle='--', alpha=0.6)

    for bar, val in zip(bars, messages):
        plt.text(
            bar.get_x() + bar.get_width() / 2,
            bar.get_height(),
            f"{val} Messages",
            ha='center',
            va='bottom',
        )

    plt.savefig("Performance_Complexity_Messages_BAR.png", dpi=300, bbox_inches='tight')
    plt.close()

    # ===============================
    # BAR CHART 2: EXECUTION TIME
    # ===============================
    plt.figure(figsize=(10, 6))
    bars = plt.bar(x_pos, times, color=colors)

    plt.xticks(x_pos, nodes)
    plt.xlabel("Node Count")
    plt.ylabel("Time (seconds)")
    plt.title("Experiment 1: Execution Time Analysis", fontweight='bold')
    plt.grid(axis='y', linestyle='--', alpha=0.6)

    for bar, val in zip(bars, times):
        plt.text(
            bar.get_x() + bar.get_width() / 2,
            bar.get_height(),
            f"{val:.3f} s",
            ha='center',
            va='bottom',
        )

    plt.savefig("Performance_Time_BAR.png", dpi=300, bbox_inches='tight')
    plt.close()


def plot_network_detailed(num_nodes=10):
    """Generates a detailed map view with distance labels."""
    G, pos, labels = load_graph_for_viz(num_nodes)
    plt.figure(figsize=(12, 8))
    nx.draw_networkx_nodes(G, pos, node_size=700, node_color='skyblue', edgecolors='black')
    nx.draw_networkx_labels(G, pos, labels, font_size=10, font_weight='bold')
    nx.draw_networkx_edges(G, pos, edge_color='gray', arrows=True, arrowsize=15, alpha=0.6)
    
    edge_labels = nx.get_edge_attributes(G, 'weight')
    formatted_edge_labels = {k: f"{v}" for k, v in edge_labels.items()}
    nx.draw_networkx_edge_labels(G, pos, edge_labels=formatted_edge_labels, font_size=8, font_color='red')
    
    plt.title(f"Real World Flight Network Sample ({num_nodes} Nodes)\nEdge Weights = Distance (km)", fontsize=14)
    plt.axis('off')
    plt.savefig(f"Network_Real_World_{num_nodes}_Nodes.png", dpi=300, bbox_inches='tight')
    plt.close()

def generate_all_visuals(json_file=DEFAULT_RESULTS_FILE):
    """Main function to trigger all plots using data from JSON."""
    print(f"--- Visualizer Started. Loading data from {json_file} ---")
    results = load_simulation_results(json_file)
    
    plot_network_detailed(10)
    
    if results:
        plot_connectivity_visuals(results)
        plot_comparison_chart_exp3(results)
        plot_scale_charts_exp1(results)
        print("--- All visualizations generated successfully. ---")
    else:
        print("[ERROR] No data loaded. Only static network map generated.")

if __name__ == "__main__":
    generate_all_visuals()